<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<title>Advanced Sound-Synthesis in OSW</title>
<link href="css/text.css" rel="stylesheet" type="text/css">
</head>

<body bgcolor="white" lang=EN-US style='tab-interval:.5in'>

<div class=Section1>
<!-- BEGIN header -->
<table border="0" width="100%">
<tr>
<td>
<a class="mantle" href="UserGuide.html" target="_top"><img src="oswmantle.png" width="453" height="94" border="0" />
</td>
<td align="left">
<h3 class="title">User Guide</h3>
</td>
</tr>
<tr>
<td colspan="2" class="menubar">
<a href="UserGuide.html" target="_top" class="menu">User Guide</a> 
|
<a href="Transform_by_group.html" target="_top" class="menu">Transform Guide</a> 
|
<a href="http://osw.sourceforge.net" target="_top" class="menu">OSW on the Web</a> 
</td>
</tr>
</table>
<!-- END header -->
<center>
<h1 class="title">6. Advanced Sound-Synthesis in OSW</h1>
</center>
<p>In the previous chapter, we explored a variety of techniques for manipulating sound signals in OSW, mostly using waveform representations.  Waveform representations of sound are similar to image representations of visual scenes. Images allow efficient transformations on groups of pixels, but very little control over perceptual or geometric features. When such control is required, a vector- or program-based representation (e.g, PostScript) is preferred. These representations are also a form of compression in that they require less space than the images they represent. Sounds can also be represented by programs, with similar advantages for compression and mutability [<a href="bibliography.html#Sch2000">Scheirer 2000</a>]. The process of generating sound from programs is called sound synthesis.  This chapter describes the more advanced synthesis techniques available in OSW, building on the concepts of oscillators and filters presented in the previous chapter.  Some of the material in the chapter is based on earlier work [<a href="bibliography.html#Cha2001">Chaudhary 2001</a>] adapted for OSW.</p>

<p>Consider a synthesis function of a pure tone with constant pitch, such as that generated by the <a class="transform" href="osw/Sinewave.html">Sinewave</a> transform:</p>
<center>
<i>y</i>(<i>n</i>) = <i>A</i>cos(2&pi;<i>n</i>)
</center>
<p>where <i>A</i> and <i>f</i> represent the peak amplitude and frequency of the sinusoid, respectively.  Instead of storing the entire duration (e.g., several seconds) of the waveform as an audio file, one need only store the instructions to generate the the waveform and the parameters <i>A</i> and <i>f</i>.  This information can be stored in a compact representation such as an OSW patch and used to generate an arbitrarily long waveform as needed.  Additionally, controlling the pitch in the patch-based functional representation is accomplished by simply scaling the parameter <i>f</i>, whereas changing the pitch of a stored waveform representation requires complex sample-rate conversion operations to avoid loss of quality (e.g. anti-aliasing to avoid degrading a scaled image).</p>
<h3 class="title">Controlling synthesis parameters: Envelopes and Modulators</h3>
<p>The parameters of a synthesis function such as a Sinewave can of course be time varying.  Thus, we can represent tones of varying pitch and amplitude functionally:</p>
<center>
<i>y</i>(<i>n</i>) = <i>A</i>(<i>n</i>)cos(2&pi;<i>f</i>(<i>n</i>)n)
</center>
<p>The varying amplitude and frequency parameters <i>A</i>(<i>n</i>) and <i>f</i>(<i>n</i>) can represent variations in user input over time, as in the following patch:</p>
<center>
<img src="advanced_files/time_varying_sinusoid.png" width="292" height="387" />
</center>
<p>These parameters can also be described by functions in OSW.  Functions that control synthesis parameters are called <i>envelope functions</i>.  An example of an envelope function that controls the amplitude of an oscillator can be found in the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/amp_envelope.osw">amplitude envelope tutorial patch</a>.  While envelope functions are often breakpoint functions (i.e., like the control points of curves in graphics), the can themselves be oscillators.  In <i>amplitude-modulation</i> (AM) synthesis, the amplitude parameter <i>A</i>(<i>n</i>) is representated by an oscillator, as illustrated in the <a href="htttp://localhost:7775/OSW_DIR/tutorials/audio/am.osw">AM tutorial patch</a>.  In <i>frequency-modulation</i> (FM) synthesis, the frequency parameter <i>f</i>(<i>n</i>) is an oscillator, as illustrated in the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/simple_fm.osw">simple FM tutorial patch</a>.</p>
<center>
<img src="advanced_files/simple_fm.png" width="563" height="507" />
</center>
<p>In the FM patch illustrated above, a Sinewave, called a <i>modulator</i> is used to drive the frequency parameter of another Sinewave, called a <i>carrier</i>.  (The <a class="transform" href="osw/SampleGet.html">SampleGet</a> transform is used to extract a single floating-point sample from a block of samples output by the modulator.)  FM synthesis will be revisited in more depth later in this chapter.</p>
 
<h3 class="title">Additive Synthesis</h3>

In the previous section, we used a synthesis function that modeled a simple time-varying sinusoid.  We can model arbitrarily complex sounds as a sum of sinusoids:

<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<A NAME="eqn2.4"></A><!-- MATH
 \begin{equation}
y(n) = \sum_{i=1}^{N}A_i(n)\cos{(2{\pi}f_i(n)t+\phi_i(n))}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP>
<I>y</I>(<I>n</I>) = <IMG
 WIDTH="27" HEIGHT="69" ALIGN="MIDDLE" BORDER="0"
 SRC="advanced_files/img8.png"
 ALT="$\displaystyle \sum_{{i=1}}^{{N}}$"><I>A</I><SUB>i</SUB>(<I>n</I>)cos(2&pi;<I>f</I><SUB>i</SUB>(<I>n</I>)<I>t</I>+&phi;<SUB>i</SUB>)
</TD>
</TR>
</TABLE>
</DIV>

<p>where <SPAN CLASS="MATH"><I>N</I></SPAN> is the total number of sinusoids, also called <I>partials</I>. Similar to the single-sinusoid case, each invidiual sinusoid has parameter functions <i>A<sub>i</sub></i>(<i>n</i>), <i>f<sub>i</sub></i>(<i>n</i>), and <i>&phi<sub>i</sub></i>(<i>n</i>) for controling amplitude, frequency and phase, respectively.   Each parameter, such as <I>A</I><SUB>i</SUB>(<I>n</I>) can represent user input, as demonstrated in the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/additive.osw">additive synthesis tutorial patch</a>.  In this patch, the amplitude functions of the partials can be controlled by the user to produce a variety of timbres.  The user can also select a fundamental frequency (i.e., pitch) for the synthesized sound.  The frequencies of all the partials are locked to integer multiples of the fundamental frequency, creating a set special set of partials called <i>harmonics</i>.  Harmonic (or near harmonic) partials are found in many acoustic musical instruments as well as elementary waveforms such as sawtooths, square waves and triangle waves.  For example, a band-limited sawtooth waveform of pitch <i>f</i> (not to be confused with the key F) can be approximated as a sum of N sinusoids with frequencies 1<i>f</i>, 2<i>f</i>, 3<i>f</i>,..., <i>Nf</i> (where <i>N</i> &lt; <i>S</i>/2<i>f</i>) and amplitudes 1, 1/2, 1/3,..., 1/<i>N</i>: </p>

<DIV ALIGN="CENTER" CLASS="mathdisplay">
<A NAME="eqn2.4"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP>
<I>y</I>(<I>n</I>) = <IMG
 WIDTH="27" HEIGHT="69" ALIGN="MIDDLE" BORDER="0"
 SRC="advanced_files/img8.png"
 ALT="$\displaystyle \sum_{{i=1}}^{{N}}$" />cos(2&pi;<I>ifn</I>)/<i>i</i>
</TD>
</TR>
</TABLE>
</DIV>
<p>You can try to simulate a limited sawtooth waveform in the additive synthesis patch by moving the harmonic-amplitude sliders to 1, 1/2, 1/3, etc.  The result should look like this:</p>
<center>
<img src="advanced_files/saw_harmonics.png" width="135" height="138" />
</center>
<p>Now we will try and approximate a square wave by removing the even partials:</p>:
<center>
<img src="advanced_files/square_harmonics.png" width="135" height="141" />
</center>
<p>The result should sound softer, somewhat &quot;clarinet-like&quot;.   Compare this result to the output of the <a class="transform" href="osw/Square.html">Square</a> transform.  The Square transform will likely be a bit sharper because its waveform is represented by more than ten partials.</p>
<p>Even with only ten harmonic partials available in this patch, you can synthesize a wide variety of timbres.  However, a far richer set of timbres is possible using larger collections of partials and using separate envelope functions for the amplitude, frequency and phase of each sinusoid.  The set of envelope functions that describe the amplitude, frequency and phase of a sinusoidal partial are called a <i>sinusoidal track</i>.  Thus, this more general additive-synthesis technique is often called <i>sinusoidal-track modeling</i>.  To get a better idea of the sinusoidal model representation, it may help to think of 3D space in which the <i>x</i> axis is time, the <i>z</i> axis (depth) is frequency and the <i>y</i> axis (height) is the amplitude.  Each track can be represented as a curve traversing this space, as illustrated in the following figure taken from the OpenSoundEdit tool [<a href="bibliography.html#Cha1998">Chaudhary 1998</a>]:</p>
<center>
<img src="advanced_files/img11.png" width="630" height="460" />
</center>

<p>Variations on sinusoidal models include ``phase vocoder'' models which usually have a fixed number of sinusoids constrained within frequency bands [<a href="bibliography.html#Dol1986">Dolson 1986</a>], and the more general ``McAulay-Quatieri'' (MQ) sinusoidal models [<a href="bibliography.html#McA1978">1978</a>] which are used by most modern computer-based additive synthesizers, including the OpenSoundEdit tool illustrated above, and OSW. In these general models we use, the number of sinusoids can vary between frames, resulting in birth and death events when a sinusoid begins or ends inside a model. </p>

<p>Among the unique features of OSW is its ability to natively express and manipulate sinusoidal models.  OSW includes a type Sinusoids, and several transforms for generating, modifying and finally synthesizing sinusoidal models using this data type.  If you have opened the additive synthesis tutorial patch, you have already encountered an example of the Sinusoids data type, as well as two important transforms: <a class="transform" href="sinusoids/List2Sinusoids.html">List2Sinusoids</a> converts OSW lists containing ordered amplitude frequency and phase values into a Sinusoids object, and <a class="transform" href="cnmat/AddSynth.html">AddSynth</a>, which synthesizes waveform representations from Sinusoids objects using an additive-synthesis algorithm.</p>

<center>
<img src="advanced_files/sinusoids_transforms.png" width="328" height="86" />
</center>  

<p>Inlets, outlets and connections of type Sinusoids are distinguished with a bright blue color.</p>
<p>While List2Sinusoids allows you to create sinusoidal models from user input or algorithmically, you can also work with large sinusoidal models stored in the Sound Description Interchange Format (<a href="sdif.htm">SDIF</a>), which is described in greater detail in <a href="sdif.htm">chapter 8</a>.  You can visit the help patch for <a class="transform" href="cnmat/AddSynth.html">AddSynth</a> for an example of synthesis from an SDIF sinusoidal model.  On that help page, you will be able to load a large sinusoidal model of a saxophone, and &quot;scrub&quot; back and forth in time and run the model at different rates.  This is one of the interesting features of sinusoidal models: controlling the temporal position and rate without affecting the pitch(es) in the model.  Compare this to the scrubbing control in the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/looping.osw">sample looping tutorial</a>, where changing the rate of progress through the sample loop also changes its frequency content, including the pitches.</p>
<p>In addition to its greater temporal mutability, sinusoidal models can be manipulated in ways that are challenging or nearly impossible when working with time-domain waveforms.  For example, the <a class="transform" href="cnmat/DropPartials.html">DropPartials</a> transform allows you to remove individual sinusoidal components, either by their index within the model, or by a frequency range.  DropPartials provides very precise control of the frequencies included and excluded from a sound, precision that would be difficult to accomplish using the filters described in the <a href="signal_processing.htm">previous chapter</a>.  Another sinusoidal-modeling effect that does not have a simple counterpart in the time domain is <a class="transform" href="cnmat/Inharmonicity.html">Inharmonicity</a>, which allows the relative spacing between partials to expand based on user input or a control function.  Inharmonicity gets its name from the fact that it makes <a href="http://localhost:7775/OSW_DIR/tutorials/audio/additive.osw">harmonic-based models</a> sound less harmonic, because its moves the partials away from integer ratios.</p>

<h3 class="title">Subtractive Synthesis and Resonance modeling</h3>

<p>In additive synthesis, complex sounds are built from simple sinusoidal components.  By contrast, in <i>subtractive synthesis</i>, one begins with a frequency-rich sound such as a <a class="transform" href="osw/Phasor.html">Phasor</a>, <a class="transform" href="osw/Square">Square</a>, <a class="transform" href="osw/WhiteNoise.html">WhiteNoise</a>, a sampled sound, or even a synthesized sinusoidal model and removing portions of the sound via filters.</p>
<center>
<img src="advanced_files/subtractive.png" width="520" height="105" />
</center>
<p>Subtractive synthesis has a long history dating back to analog synthesizers, which used resonant filters.  Subtractive synthesis has also been popular in more recent digital synthesis, which use resonant filters such as those that can be represented using the <a class="transform" href="osw/Biquad.html">Biquad</a> and <a class="transform" href="osw/TwoPoleResonz.html">TwoPoleResonz</a> transforms or more complex filter topologies.</p>
<p>Subtractive synthesis with banks of resonant filters can be used to model resonant acoustic systems.  This synthesis technique is called <i>resonance modeling</i>.  Given an excitation waveform <i>x</i>(<i>n</i>), the resonance of an acoustic system can be modeled as a bank of second-order filters (e.g., similar to Biquad or TwoPoleResonz):</p>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="resfilter"></A><A NAME="sumfilters"></A><!-- MATH
 \begin{eqnarray}
y_i(n) & = & a_{i}x(n)+b_{1i}y_{i}(n-1)+b_{2i}y_{i}(n-2) \\y(n) & = & \sum_{i=1}^{N}y_i(n)
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>y</I><SUB>i</SUB>(<I>n</I>)</TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP><I>a</I><SUB>i</SUB><I>x</I>(<I>n</I>) + <I>b</I><SUB>1i</SUB><I>y</I><SUB>i</SUB>(<I>n</I> - 1) + <I>b</I><SUB>2i</SUB><I>y</I><SUB>i</SUB>(<I>n</I> - 2)</TD>
</TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>y</I>(<I>n</I>)</TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="27" HEIGHT="69" ALIGN="MIDDLE" BORDER="0"
 SRC="advanced_files/img8.png"
 ALT="$\displaystyle \sum_{{i=1}}^{{N}}$"><I>y</I><SUB>i</SUB>(<I>n</I>)</TD>
</TR>
</TABLE></DIV>
<p>where <SPAN CLASS="MATH"><I>N</I></SPAN> is the number of filters in the resonance model, <SPAN CLASS="MATH"><I>y</I><SUB>i</SUB>(<I>n</I>)</SPAN> is the response of the <I>i</I>th filter, <SPAN CLASS="MATH"><I>a</I><SUB>i</SUB></SPAN> is the input scaling coefficient for the filter and <SPAN CLASS="MATH"><I>b</I><SUB>1</SUB><I>i</I></SPAN> and <SPAN CLASS="MATH"><I>b</I><SUB>2</SUB><I>i</I></SPAN> are the feedback coefficients for the previous two samples.  The coefficients of each filter can be expressed in terms of more perceptually meaningful parameters: amplitude, frequency and bandwidth:</p>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="resFilterDefs"></A><!-- MATH
 \begin{eqnarray}
a_i & = & A_i \\
r_i & = & e^{-{\pi}k_{i}/S} \\
b_1i & = & 2r\cos{2{\pi}f/S} \\
b_2i & = & -r^2
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>a</I><SUB>i</SUB></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP><I>A</I><SUB>i</SUB></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
</TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>r</I><SUB>i</SUB></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP><I>e</I><SUP>-&pi;
k<SUB>i</SUB>/S</SUP></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
</TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>b</I><SUB>1</SUB><I>i</I></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP>2<I>r</I> cos2&pi;<I>f</I> /<I>S</I></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
</TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>b</I><SUB>2</SUB><I>i</I></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP>- <I>r</I><SUP>2</SUP></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
</TR>
</TABLE></DIV>

<p>where <SPAN CLASS="MATH"><I>S</I></SPAN> is the sample rate of the output waveform and <SPAN CLASS="MATH"><I>A</I><SUB>i</SUB></SPAN>, <SPAN CLASS="MATH"><I>f</I><SUB>i</SUB></SPAN> and <SPAN CLASS="MATH"><I>k</I><SUB>i</SUB></SPAN> are the amplitude, frequency and bandwidth, respectively, of the <I>i</I>th resonant filter.</p>
<p>OSW provides a transform, <a class="transform" href="cnmat/Resonators.html">Resonators</a>, that implements a bank of resonant filters as a single unit.  It accepts input for the excitation source and an argument of type Resonances that describes the amplitude, frequency and bandwidth of each filter.</p>
<center>
<img src="advanced_files/resonators.png" width="567" height="441" />
</center>
<p>Similar to Sinusoids, the Resonances data type is a very mutable form that can be scaled based on user input or control functions via transforms such as <a class="transform" href="cnmat/ScaleResonances.html">ScaleResonances</a> and <a class="transform" href="cnmat/JitterRes.html">JitterRes</a>.  Source material for resonance models can be derived from user input or algorithmically via the <a class="transform" href="cnmat/List2Resonances.html">List2Resonances</a> transform, or from <a class="transform" href="sdif.htm">SDIF</a> files via the <a class="transform" href="sdif/ToResonances.html">sdif::ToResonances</a> transform.</p>
<P>
If the excitation is an impulse, the resonance can be modeled as a special case of additive synthesis in which the frequency and phase of each sinusoid is constant and the amplitude decays exponentially:

<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<A NAME="equationExpDecay"></A><!-- MATH
 \begin{equation}
y(n) = \sum_{i=1}^{N}A_{i}e^{-{\pi}k_{i}n}\cos{2{\pi}f_{i}n}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP>
<I>y</I>(<I>n</I>) = <IMG
 WIDTH="27" HEIGHT="69" ALIGN="MIDDLE" BORDER="0"
 SRC="advanced_files/img8.png"
 ALT="$\displaystyle \sum_{{i=1}}^{{N}}$"><I>A</I><SUB>i</SUB><I>e</I><SUP>-
 &pi;
<I>f</I><SUB>i</SUB><I>n</I>
</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
</TR>
</TABLE>
</DIV>
<p>The amplitude <SPAN CLASS="MATH"><I>A</I><SUB>i</SUB></SPAN> determines initial energy of the partial, and the bandwidth <SPAN CLASS="MATH"><I>k</I><SUB>i</SUB></SPAN> determines the rate of decay. A&nbsp;smaller bandwidth means a longer decay, and a bandwidth of zero means the resonance stays at constant amplitude.  Since the entire evolution of each decaying sinusoid is defined by just three numbers, resonance models require far less data to specify than general additive synthesis.  Any instrument that is struck, plucked, or otherwise driven by a single brief burst of energy per tone can be efficiently modeled using impulse-driven resonances.  These instruments include pianos, most percussion instruments, plucked strings, and many of the modern extended techniques for traditional orchestral instruments (e.g., key clicks on wind instruments). 
<p>Resonances can also be excited by non-impulse signals.  Visit the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/noisy_resonances.osw">noisy resonance</a> tutorial patch to see an example of a resonance model excited with a noise generator.  Mixing various excitation signals, such as breath noise, with resonant systems, such as struck metallic objects, can produce interesting hybrid instrument models.</p>
<p>Although the component resonance partials of a model are excited simultaneously, OSW includes a transform <a class="transform" href="cnmat/ResPing.html">ResPing</a> for exploring a model by exciting individual resonances.  This can be used for non-simultaneous effects, such as arpeggiation or &quot;strumming&quot; of resonance models.  Visit the <a href="http://localhost:7775/OSW_DIR/demos/Resonances/Arpeggiator.osw">Resonance Arpeggiator</a> demo to hear an example of individual resonances excited in sequence.</p>

<h3 class="title">Wavetables and Waveshaping Synthesis</h3>
<p>We have already used several of the oscillator transforms that are available in OSW, such as <a class="transform" href="osw/Sinewave.html">Sinewave</a>, <a class="transform" href="osw/Phasor.html">Phasor</a>, and <a class="transform" href="osw/WhiteNoise.html">WhiteNoise</a>.  These transforms provide efficient implementations of frequently used oscillator functions.  However, there are times when you will want to &quot;create your own oscillators&quot; based on other periodic functions, or require finer control over oscillator functions.  The <a class="transform" href="osw/Wavetable.html">WaveTable</a> transform in OSW allows you to create and control oscillators via a technique called <i>wavetable synthesis</i>.  In wavetable synthesis, a small waveform is stored in a table, which in OSW can be either a <a class="transform" href="Table.html">Table</a> or <a class="transform" href="osw/SampleBuffer.html">SampleBuffer</a>, and treated as a single period of a repeating waveform.  The WaveTable transform accepts a signal representing phase values an input, and returns the corresponding value from the wave table.  Thus, if the phase values repeat with a given frequency, a periodic signal will be generated based on the wavetable with the frequency as its fundamental period.</p>
<p>The most common source of phase input for a wavetable is the <a class="transform" href="osw/Phasor.html">Phasor</a> transform (in fact, this is how it gets its name).  It can be connected to a WaveTable to sweep through the wavetable periodically.</p>
<center>
<img src="advanced_files/wavetable.png" width="156" height="286" />
</center>

<p>By default, the WaveTable transform uses a built-in table called <b>/sine</b> as its table.  Thus connecting a Phasor to a WaveTable yields another method for generating sine waves.  The built in tables available for the WaveTable transform include:</p>
<ul>
<li><b>/sine</b>: one
period of a sine function (between 0 and 2<span style='font-family:Symbol;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>p</span></span>)</li>

<li><b>/cosine</b>: one period of a cosine function (between 0 and 2<span style='font-family:
Symbol;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>p</span></span>)</li>

<li><b>/exp</b>: the function <i>e<sup>-x</sup> </i>evaluated between 0 and <span
style='font-family:Symbol;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span></li>

<li><b>/sinc</b>:<span style="mso-spacerun: yes"> 
</span>the “sinc” function sin(<i>x</i>)/<i>x</i> evaluated between -<span
style='font-family:Symbol;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span> and <span
style='font-family:Symbol;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span>.  This is a useful function for generating <a href="http://localhost:7775/OSW_DIR/tutorials/audio/pulse_train.osw">pulse trains</a> via wavetable synthesis.</li>
</ul>
<p>You can of course load your own tables from external files into a SampleBuffer, or create your own tables on the fly using the <a class="transform" href="Table.html">Table</a> transform.</p>

<p>So far, we have exclusively used the Phasor transform to provide a regular source of phase information to the wave table.  However, any signal can be used as input to a wavetable.  When more general signals are used as input to wavetables, the technique is known as <i>wave-shaping synthesis</i>.  Load the waveshaping <a href="http://localhost:7775/OSW_DIR/tutorials/audio/waveshaping_synthesis.osw">tutorial patch</a> to see what happens when a sine wave instead of a Phasor is used as the source signal for different wavetables.</p>
<center>
<img src="advanced_files/waveshaping.png" width="431" height="376" />
</center>
<h3 class="title">FM Synthesis Revisited</h3>
<p>In the context of wavetable synthesis, frequency-modulation can be seen as the application of a modulator to a phasor, as illustrated in the <a href="http://localhost:7775/OSW_DIR/tutorials/audio/fm.osw">FM tutorial patch.</a>  Although this technique is more accurlately called &quot;phase modulation&quot; the name &quot;frequency modulation&quot; is still used in practice and the behavior of this patch is similar to the technique used in &quot;classic FM&quot; synthesizers[<a href="bibliography.html#Cho1985">Chowning 1985</a>]. The tutorial patch can be extended to include additional modulators (certain popular FM synthesizers with the letter X and various numbers in their names used four or six oscillators arranged in various groups of nested carriers and modulators).</p>

<h3 class="title">Granular Synthesis</h3>

<p>Granular synthesis is an alternative to additive synthesis that is based on a theory developed by Gabor [<a href="bibliography.html#Roa1988">Roads 1988</a>]. In granular synthesis, a waveform representation is decomposed into tiny waveform representations, called grains. A new waveform is synthesized by selecting a sequence of grains, scaling each grain by an envelope function and combining them in an overlap-add process. If the sequence of grains is exactly the same as the sequence from the analysis, the original waveform representation will be resynthesized. If grains from the analysis sequence are removed without changing the order of the remaining grains, a time-compressed version of the original waveform will be synthesized. If grains are repeated without changing the order (i.e., sequence <i>G</i><sub>1</sub>, <i>G</i><sub>2</sub> <i>G</i><sub>3</sub>,... becomes <i>G</i><sub>1</sub>, <i>G</i><sub>1</sub>,..., <i>G</i><sub>2</sub>, <i>G</i><sub>2</sub>,..., <i>G</i><sub>3</sub>,...), then a time-stretched version is synthesized. Thus, similar to additive synthesis, granular synthesis affords independent control over the duration of synthesized waveform representations. If the length of each grain is proportional to the pitch period (i.e., the inverse of the pitch) of the analyzed waveform, then the pitch of original waveform can be independently scaled as well.</p>
<p>OSW includes a transform <a class="transform" href="osw/Granulator.html">Granulator</a> that performs real-time granular decomposition and synthesis on  waveform representations stored in <a class="transform" href="osw/SampleBuffer.html">SampleBuffers</a>.  The user can adjust the size of the grains, the number of grains available simulataneously. A typical grain size in granular synthesis is 20ms, or 882 samples at a 44100Hz sampling rate. Experimentation with larger and smaller grain sizes is encouraged.</p>

<h3 class="title">A final note on synthesis</h3>
<p>The survey of synthesis techniques described in this chapter is by no means exhaustive.  Many more techniques can be derived from basic building blocks provided by OSW.</p>

<!-- BEGIN footer -->
<hr />
<a target="_top" href="http://osw.sourceforge.net">Open Sound World</a> User Guide<br />
&copy; 2000-2004 Amar Chaudhary.  All rights reserved.
<!-- END footer -->
</body>







